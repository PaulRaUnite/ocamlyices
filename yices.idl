/*
Copyright (c) 2010, Mickaël Delahaye <mickael.delahaye@gmail.com>

Permission to use, copy, modify, and/or distribute this software for any purpose
with or without fee is hereby granted, provided that the above copyright notice
and this permission notice appear in all copies.

THE SOFTWARE IS PROVIDED “AS IS” AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS
OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF
THIS SOFTWARE.
*/

/*
 CAMLIDL of Yices C interface
*/

[long_default(nativeint)] interface yices {

typedef [abstract,errorcheck(check_expr)] void * expr;

typedef [abstract,errorcheck(check_type)] void * typ;
typedef [ref] typ* ptyp;
typedef [abstract,errorcheck(check_var_decl)] void * var_decl;
typedef [abstract,errorcheck(check_context)] void * context;
typedef int assertion_id;
typedef [abstract,errorcheck(check_model)] void * model;
typedef [abstract,errorcheck(check_var_decl_iterator)] void * var_decl_iterator;

enum lbool { False=-1, Undef, True };

[mlname(set_verbosity)]
void yices_set_verbosity(int l);

[mlname(version), string]
char * yices_version();

[mlname(set_max_num_conflicts_in_maxsat_iteration)]
void yices_set_max_num_conflicts_in_maxsat_iteration(unsigned int n);
[mlname(enable_type_checker)]
void yices_enable_type_checker(boolean flag);
[mlname(set_max_num_iterations_in_maxsat)]
void yices_set_max_num_iterations_in_maxsat (unsigned int n);
[mlname(set_maxsat_initial_cost)]
void yices_set_maxsat_initial_cost(long long c);
[mlname(set_arith_only)]
void yices_set_arith_only(boolean flag);
[mlname(enable_log_file)]
void yices_enable_log_file([string] char * file_name);

[mlname(mk_context)]
context yices_mk_context();
[mlname(del_context)]
void yices_del_context(context ctx);
[mlname(reset)]
void yices_reset(context ctx);
[mlname(dump_context)]
void yices_dump_context(context ctx);
[mlname(push)]
void yices_push(context ctx);
[mlname(pop)]
void yices_pop(context ctx);

[mlname(interrupt)]
void yices_interrupt(context ctx);

[mlname(assert_simple)]
void yices_assert(context ctx, expr expr);
[mlname(assert_weighted)]
assertion_id yices_assert_weighted(context ctx, expr expr, long long w);
[mlname(assert_retractable)]
assertion_id yices_assert_retractable(context ctx, expr expr);
[mlname(retract)]
void yices_retract(context ctx, assertion_id id);

[mlname(inconsistent)]
int yices_inconsistent(context ctx);

[mlname(check)]
enum lbool yices_check(context ctx);
[mlname(find_weighted_model)]
enum lbool yices_find_weighted_model(context ctx, int random);

[mlname(evaluate_in_model)]
enum lbool yices_evaluate_in_model(model m, expr e);  

[mlname(max_sat)]
enum lbool yices_max_sat(context ctx);
[mlname(max_sat_cost_leq)]
enum lbool yices_max_sat_cost_leq(context c, long long max_cost);

[mlname(get_model)]
model yices_get_model(context ctx);

// Get the unsat core
struct unsat_core { int length; [size_is(length)] assertion_id *array; };
[mlname(get_unsat_core)]
struct unsat_core get_unsat_core(context ctx) quote(dealloc,"free(_res.array);");

[mlname(get_value)]
enum lbool yices_get_value(model m, var_decl v);

typedef [errorcode,errorcheck(check_value_error)] int value_error;

[mlname(get_int_value)]
value_error yices_get_int_value(model m, var_decl d, [out] long* v);
[mlname(get_arith_value)]
value_error yices_get_arith_value(model m, var_decl d, [out] long *num, [out] long *den);
[mlname(get_double_value)]
value_error yices_get_double_value(model m, var_decl d, [out] double *v);
[mlname(get_bitvector_value)]
int yices_get_bitvector_value(model m, var_decl d, unsigned int n, [size_is(n)] int bv[]);
[mlname(get_assertion_value)]
int yices_get_assertion_value(model m, assertion_id id);

[string] char* get_rational_value_as_string(model m, var_decl d) quote(dealloc,"if (_res) free(_res);");
[string] char* get_integer_value_as_string(model m, var_decl d) quote(dealloc,"if (_res) free(_res);");

quote(ml,"let get_ratio_value m d =\
  Ratio.ratio_of_string (get_rational_value_as_string m d);;\n\n\
let get_big_int_value m d =\
  Big_int.big_int_of_string (get_integer_value_as_string m d);;\n")
quote(mli,"val get_ratio_value : model -> var_decl -> Ratio.ratio\n\n\
val get_big_int_value : model -> var_decl -> Big_int.big_int\n")

[mlname(get_display_model)]
void yices_display_model(model m);

[mlname(get_cost)]
long long yices_get_cost(model m);
[mlname(get_cost_as_double)]
double yices_get_cost_as_double(model m);

[mlname(mk_true)]
expr yices_mk_true(context ctx);
[mlname(mk_false)]
expr yices_mk_false(context ctx);
[mlname(mk_bool_var)]
expr yices_mk_bool_var(context ctx, [string] char * name);
[mlname(mk_fresh_bool_var)]
expr yices_mk_fresh_bool_var(context ctx);

[mlname(get_var_decl)]
var_decl yices_get_var_decl(expr e);
[mlname(mk_bool_var_decl)]
var_decl yices_mk_bool_var_decl(context ctx, [string] char * name);

[mlname(get_var_decl_name),string]
char * yices_get_var_decl_name(var_decl d);

[mlname(mk_bool_var_from_decl)]
expr yices_mk_bool_var_from_decl(context ctx, var_decl d);
[mlname(mk_or)]
expr yices_mk_or(context ctx, [size_is(n)] expr args[], unsigned int n);
[mlname(mk_and)]
expr yices_mk_and(context ctx, [size_is(n)] expr args[], unsigned int n);
[mlname(mk_eq)]
expr yices_mk_eq(context ctx, expr a1, expr a2);
[mlname(mk_diseq)]
expr yices_mk_diseq(context ctx, expr a1, expr a2);
[mlname(mk_ite)]
expr yices_mk_ite(context ctx, expr c, expr t, expr e);
[mlname(mk_not)]
expr yices_mk_not(context ctx, expr a);

// dont export var_decl_iterator
quote(mli,"(*")
var_decl_iterator yices_create_var_decl_iterator(context c);
boolean yices_iterator_has_next(var_decl_iterator it);
var_decl yices_iterator_next(var_decl_iterator it);
//void yices_iterator_reset(var_decl_iterator it);
void yices_del_iterator(var_decl_iterator it);
quote(mli,"*)")

quote(ml,"let iter_bool_var_decl f ctx = \n\
  let it = yices_create_var_decl_iterator ctx in\n\
    while yices_iterator_has_next it do\n\
      f (yices_iterator_next it);\n\
    done;\n\
    yices_del_iterator it;;\n");
quote(mli,"val iter_bool_var_decl: (var_decl -> unit) -> context -> unit;;\n");

[mlname(mk_type)]
typ yices_mk_type(context ctx, [string] char * name);

// built-in types: number, real, int, nat, bool, any
quote(ml,"let number_type_name = \"number\";;\n\
let real_type_name = \"real\";;\n\
let int_type_name = \"int\";;\n\
let nat_type_name = \"nat\";;\n\
let bool_type_name = \"bool\";;\n\
let any_type_name = \"any\";;\n")
quote(mli,"val number_type_name : string\n\
val real_type_name : string\n\
val int_type_name : string\n\
val nat_type_name : string\n\
val bool_type_name : string\n\
val any_type_name : string\n")

[mlname(mk_function_type)]
typ yices_mk_function_type(context ctx, [size_is(domain_size)] typ domain[], 
  unsigned int domain_size, typ range);
[mlname(mk_bitvector_type)]
typ yices_mk_bitvector_type(context ctx, unsigned int size);
[mlname(mk_tuple_type)]
typ yices_mk_tuple_type(context ctx, [size_is(size)] ptyp args[],
  unsigned int size);

[mlname(mk_var_decl)]
var_decl yices_mk_var_decl(context ctx, [string] char * name, typ ty);
[mlname(get_var_decl_from_name)]
var_decl yices_get_var_decl_from_name(context ctx, [string] char * name);

[mlname(mk_var_from_decl)]
expr yices_mk_var_from_decl(context ctx, var_decl d);

[mlname(mk_app)]
expr yices_mk_app(context ctx, expr f, [size_is(n)] expr args[], unsigned int n);

[mlname(mk_num)]
expr yices_mk_num(context ctx, int n);

[mlname(mk_num_from_string)]
expr yices_mk_num_from_string(context ctx, [string] char * n);

// gmp functions: must be covered by yices_mk_num_from_string
// expr yices_mk_num_from_mpz(context ctx, const mpz_t z);
// expr yices_mk_num_from_mpq(context ctx, const mpq_t q);

[mlname(mk_sum)]
expr yices_mk_sum(context ctx, [size_is(n)] expr args[], unsigned int n);
[mlname(mk_sub)]
expr yices_mk_sub(context ctx, [size_is(n)] expr args[], unsigned int n);
[mlname(mk_mul)]
expr yices_mk_mul(context ctx, [size_is(n)] expr args[], unsigned int n);
[mlname(mk_lt)]
expr yices_mk_lt(context ctx, expr a1, expr a2);
[mlname(mk_le)]
expr yices_mk_le(context ctx, expr a1, expr a2);
[mlname(mk_gt)]
expr yices_mk_gt(context ctx, expr a1, expr a2);
[mlname(mk_ge)]
expr yices_mk_ge(context ctx, expr a1, expr a2);

[mlname(mk_bv_constant)]
expr yices_mk_bv_constant(context ctx, unsigned int size, unsigned long val);
[mlname(mk_bv_constant_from_array)]
expr yices_mk_bv_constant_from_array(context ctx, unsigned int size, [size_is(size)] boolean bv[]);
[mlname(mk_bv_add)]
expr yices_mk_bv_add(context ctx, expr a1, expr a2);
[mlname(mk_bv_sub)]
expr yices_mk_bv_sub(context ctx, expr a1, expr a2);
[mlname(mk_bv_mul)]
expr yices_mk_bv_mul(context ctx, expr a1, expr a2);
[mlname(mk_bv_minus)]
expr yices_mk_bv_minus(context ctx, expr a1);
[mlname(mk_bv_concat)]
expr yices_mk_bv_concat(context ctx, expr a1, expr a2);
[mlname(mk_bv_and)]
expr yices_mk_bv_and(context ctx, expr a1, expr a2);
[mlname(mk_bv_or)]
expr yices_mk_bv_or(context ctx, expr a1, expr a2);
[mlname(mk_bv_xor)]
expr yices_mk_bv_xor(context ctx, expr a1, expr a2);
[mlname(mk_bv_not)]
expr yices_mk_bv_not(context ctx, expr a1);
[mlname(mk_bv_extract)]
expr yices_mk_bv_extract(context ctx, unsigned int end, unsigned int begin, expr a);
[mlname(mk_bv_sign_extend)]
expr yices_mk_bv_sign_extend(context ctx, expr a, unsigned int n);
[mlname(mk_bv_shift_left0)]
expr yices_mk_bv_shift_left0(context ctx, expr a, unsigned int n);
[mlname(mk_bv_shift_left1)]
expr yices_mk_bv_shift_left1(context ctx, expr a, unsigned int n);
[mlname(mk_bv_shift_right0)]
expr yices_mk_bv_shift_right0(context ctx, expr a, unsigned int n);
[mlname(mk_bv_shift_right1)]
expr yices_mk_bv_shift_right1(context ctx, expr a, unsigned int n);
[mlname(mk_bv_lt)]
expr yices_mk_bv_lt(context ctx, expr a1, expr a2);
[mlname(mk_bv_le)]
expr yices_mk_bv_le(context ctx, expr a1, expr a2);
[mlname(mk_bv_gt)]
expr yices_mk_bv_gt(context ctx, expr a1, expr a2);
[mlname(mk_bv_ge)]
expr yices_mk_bv_ge(context ctx, expr a1, expr a2);
[mlname(mk_bv_slt)]
expr yices_mk_bv_slt(context ctx, expr a1, expr a2);
[mlname(mk_bv_sle)]
expr yices_mk_bv_sle(context ctx, expr a1, expr a2);
[mlname(mk_bv_sgt)]
expr yices_mk_bv_sgt(context ctx, expr a1, expr a2);
[mlname(mk_bv_sge)]
expr yices_mk_bv_sge(context ctx, expr a1, expr a2);

[mlname(pp_expr)]
void yices_pp_expr(expr e);

}
