--- yices_c.h
+++ yices.idl
@@ -1,22 +1,22 @@
 /* Copyright (c) SRI International 2006.
    Author: Leonardo de Moura.
    Revisions: Bruno Dutertre.	 
+
+   Patch for Camlidl: MickaÃ«l Delahaye.
 */
-#ifndef YICES_C_H
-#define YICES_C_H
 
-#ifdef __cplusplus
-extern "C" {
-#endif
+[long_default(nativeint)] interface yices {
 
-typedef void * yices_ast;
+import "yicesl.idl";
 
 /**
    \defgroup capi C API
 
-*/
+ */
 /*@{*/
-
+quote(mli,"(**OCaml API\n\n\
+  See the official {{:http://yices.csl.sri.com/capi.shtml} C API documentation}\n\
+*)\n")
 /**
    The current C API is not yet complete, but the basic Yices functionalities can be used.
    Dependent types, quantifiers, lambda expressions are not supported by this API right now
@@ -25,10 +25,11 @@
 
 
 /** \brief Yices expressions (abstract syntax tree) */
-typedef void * yices_expr;
+typedef [abstract,errorcheck(check_expr)] void * yices_expr;
 
 /** \brief Yices types (abstract syntax tree) */
-typedef void * yices_type;
+typedef [abstract,errorcheck(check_type)] void * yices_type;
+typedef [ref] yices_type* yices_type_ptr;
 
 /** 
    \brief Variable declaration 
@@ -39,7 +40,7 @@
    expressions. Instances can be created using
    #yices_mk_bool_var_from_decl or #yices_mk_var_from_decl.
 */
-typedef void * yices_var_decl;
+typedef [abstract,errorcheck(check_var_decl)] void * yices_var_decl;
 
 /** 
    \brief Yices context.
@@ -47,13 +48,15 @@
    A context stores a collection of declarations and assertions.
 
  */
-typedef void * yices_context;
+typedef [abstract,errorcheck(check_context)] void * yices_context;
 
 /**
    \brief Assertion index, to identify retractable assertions.  
  */
 typedef int assertion_id;
 
+typedef [abstract, errorcode,errorcheck(check_error_value)] int error_value;
+
 /**
   \brief Model.
 
@@ -62,18 +65,18 @@
   The model is constructed by calling #yices_check (or its relatives) then
   #yices_get_model.
 */
-typedef void * yices_model;
+typedef [abstract,errorcheck(check_model)] void * yices_model;
 
 /**
    \brief Iterator for scanning the boolean variables.
 */
-typedef void * yices_var_decl_iterator;
+typedef [abstract,errorcheck(check_var_decl_iterator)] void * yices_var_decl_iterator;
 
 
 /** 
   \brief Extended booleans: to represent the value of literals in the context 
 */
-typedef enum { l_false=-1, l_undef, l_true } lbool;
+enum lbool { False=-1, Undef, True };
 
 
 
@@ -85,6 +88,7 @@
 /**
    \brief Return the yices version number.
 */
+[string]
 char * yices_version();
 
 /**
@@ -93,19 +97,19 @@
 
    If the maximum is reached, then "unknown" (i.e., l_undef) is returned by maxsat.
  */
-void yices_set_max_num_conflicts_in_maxsat_iteration(unsigned n);
+void yices_set_max_num_conflicts_in_maxsat_iteration(unsigned int n);
 
 /**
    \brief Force Yices to type check expressions when they are asserted (default = false).
  */
-void yices_enable_type_checker(int flag);
+void yices_enable_type_checker(boolean flag);
 
 /**
    \brief Set the maximum number of iterations in the MaxSAT algorithm.
 
    If the maximum is reached, then "unknown" (i.e., l_undef) is returned by maxsat.
  */
-void yices_set_max_num_iterations_in_maxsat (unsigned n);
+void yices_set_max_num_iterations_in_maxsat (unsigned int n);
 
 /**
    \brief Set the initial cost for a maxsat problem.
@@ -117,14 +121,14 @@
 
    This flag usually improves performance (default = false).
  */
-void yices_set_arith_only(int flag);
+void yices_set_arith_only(boolean flag);
 
 /**
    \brief Enable a log file that will store the assertions, checks, decls, etc.
 
    If the log file is already open, then nothing happens.
  */
-void yices_enable_log_file(char * file_name);
+void yices_enable_log_file([string] char * file_name);
 
 /**
    \brief Create a logical context.
@@ -178,6 +182,7 @@
    After one assertion, the logical context may become inconsistent.
    The method #yices_inconsistent may be used to check that.       
  */
+[mlname(assert_simple)]
 void yices_assert(yices_context ctx, yices_expr expr);
 
 /**
@@ -224,7 +229,8 @@
 
    \warning This method ignore the weights associated with the constraints.  
  */
-lbool yices_check(yices_context ctx);
+[blocking]
+enum lbool yices_check(yices_context ctx);
 
 
 /**
@@ -249,7 +255,8 @@
   formulas for which yices is incomplete (e.g., quantifiers). Do not
   use the model in this case.
 */
-lbool yices_find_weighted_model(yices_context ctx, int random);
+[blocking]
+enum lbool yices_find_weighted_model(yices_context ctx, int random);
 
 
 /**
@@ -264,7 +271,7 @@
         typically this is due to a function application, e.g., 
 	the model defines (f 1) and (f 2), but the formula references (f 3)
 */
-lbool yices_evaluate_in_model(yices_model m, yices_expr e);  
+enum lbool yices_evaluate_in_model(yices_model m, yices_expr e);  
 
 
 /**
@@ -279,7 +286,8 @@
 			 
    \sa yices_assert_weighted
 */
-lbool yices_max_sat(yices_context ctx);
+[blocking]
+enum lbool yices_max_sat(yices_context ctx);
 
 /**
    \brief Similar to yices_max_sat, but start looking for models with cost
@@ -287,7 +295,8 @@
 
    \return l_false if such a model doesn't exist.
  */
-lbool yices_max_sat_cost_leq(yices_context c, long long max_cost);
+[blocking]
+enum lbool yices_max_sat_cost_leq(yices_context c, long long max_cost);
 
 
 
@@ -303,43 +312,12 @@
 yices_model yices_get_model(yices_context ctx);
 
 
+// Get the unsat core
 
-/**
-   \brief Get the size of the unsat core
-
-   The unsat core is constructed after a call to #yices_check 
-   if the context is found unsatisfiable. It's an unsatisfiable 
-   subset of the retractable assertions (represented as an array
-   of \c assertion_ids). This function returns the size of that 
-   set.
-
-   Return 0 if there's no unsat core.
-
-   \sa yices_get_unsat_core
-**/
-unsigned yices_get_unsat_core_size(yices_context ctx);
-
-
-
-/**
-   \brief Copy the unsat core into array a
-
-   \warning a must be large enough to store the core 
-   (check the size first using #yices_get_unsat_core_size)
-
-   Each element in a is the id of a retractable assertion 
-
-   Return the number of elements copied into a (which is 
-   equal to the unsat core size as returned by 
-   #yices_get_unsat_core_size)
-
-   \sa yices_assert_retractable
-   \sa yices_get_unsat_core_size
-
-**/
-unsigned yices_get_unsat_core(yices_context ctx, assertion_id a[]);    
-
+quote(mli,"(** {i (OCaml-specific)} Get the unsat core. Each element is the id of a retractable assertion. *)")
+struct unsat_core { int length; [size_is(length)] assertion_id *array; };
 
+struct unsat_core get_unsat_core(yices_context ctx) quote(dealloc,"free(_res.array);");
 
 /**
    \brief Return the assignment for the variable \c v. 
@@ -352,8 +330,7 @@
    \sa yices_get_arith_value
    \sa yices_get_double_value
  */
-lbool yices_get_value(yices_model m, yices_var_decl v);
-
+enum lbool yices_get_value(yices_model m, yices_var_decl v);
 
 /**
    \brief Get the integer value assigned to variable \c v in model \c m
@@ -371,7 +348,7 @@
    \sa yices_get_arith_value
    \sa yices_get_double_value
 */
-int yices_get_int_value(yices_model m, yices_var_decl d, long *value);
+error_value yices_get_int_value(yices_model m, yices_var_decl d, [out] long* v);
 
 
 /**
@@ -391,7 +368,7 @@
    \sa yices_get_int_value
    \sa yices_get_double_value
 */
-int yices_get_arith_value(yices_model m, yices_var_decl d, long *num, long *den);
+error_value yices_get_arith_value(yices_model m, yices_var_decl d, [out] long *num, [out] long *den);
 
 
 /**
@@ -409,55 +386,7 @@
    \sa yices_get_int_value
    \sa yices_get_arith_value
 */
-int yices_get_double_value(yices_model m, yices_var_decl d, double *value);
-
-
-/**
-   \brief Convert the value assigned to variable \c v in model \c m to a GMP rational (\c mpq_t)  
-
-   Return 1 on success.
-
-   A return code of 0 indicates one of the following errors:
-   - \c v is not a proper declaration or not the declaration of a numerical variable
-   - \c v has no value assigned in model m (typically, this means that v does not 
-   occur in the asserted constraints)
-
-   \warning 
-   - For this function to be declared properly, put \#include <gmp.h>
-   before \#include <yices_c.h> in your code. If you don't need GMP numbers, don't include <gmp.h>.
-   - The \c mpq_t object \c value must be initialized first, by calling GMP's <tt>mpq_init</tt> function.
-   (Check the GNU MP documentation).
-  
-
-   \sa yices_get_mpz_value.
-*/
-#ifdef __GMP_H__
-int yices_get_mpq_value(yices_model m, yices_var_decl d, mpq_t value);
-#endif
-
-/**
-   \brief Convert the value assigned to variable \c v in model \c m to a GMP integer (\c mpz_t)
-
-   Return 1 on success
-
-   A return code of 0 indicates one of the following errors:
-   - \c v is not a proper declaration or not the declaration of a numerical variable
-   - \c v has no value assigned in model m (typically, this means that v does not 
-   occur in the asserted constraints)
-   - \c the value assigned to v is not an integer.
-
-   \warning 
-   - For this function to be declared properly, put <tt>\#include <gmp.h></tt>
-   before <tt>\#include <yices_c.h></tt> in your code. If you don't need GMP numbers, don't include <gmp.h>.
-   - The \c mpz_t object \c value must be initialized first, by calling GMP's <tt>mpz_init</tt> function
-   or its variants. (Check the GNU MP documentation).
-
-   \sa yices_get_mpq_value.
-*/
-#ifdef __GMP_H__
-int yices_get_mpz_value(yices_model m, yices_var_decl d, mpz_t value);
-#endif
-
+error_value yices_get_double_value(yices_model m, yices_var_decl d, [out] double *v);
 
 
 /**
@@ -476,7 +405,19 @@
    - \c d is not assigned a value in model m   
    
 */
-int yices_get_bitvector_value(yices_model m, yices_var_decl d, unsigned n, int bv[]);
+int yices_get_bitvector_value(yices_model m, yices_var_decl d, unsigned int n, [size_is(n)] int bv[]);
+
+
+[string] char* get_rational_value_as_string(yices_model m, yices_var_decl d) quote(dealloc,"if (_res) free(_res);");
+[string] char* get_integer_value_as_string(yices_model m, yices_var_decl d) quote(dealloc,"if (_res) free(_res);");
+
+quote(ml,"let get_ratio_value m d =\
+  Ratio.ratio_of_string (get_rational_value_as_string m d);;\n\n\
+let get_big_int_value m d =\
+  Big_int.big_int_of_string (get_integer_value_as_string m d);;\n")
+quote(mli,"val get_ratio_value : model -> var_decl -> Ratio.ratio\n\n\
+val get_big_int_value : model -> var_decl -> Big_int.big_int\n")
+
 
 
 /**
@@ -536,7 +477,7 @@
    \sa yices_mk_fresh_bool_var
    \sa yices_mk_bool_var_from_decl
  */
-yices_expr yices_mk_bool_var(yices_context ctx, char * name);
+yices_expr yices_mk_bool_var(yices_context ctx, [string] char * name);
 
 
 /**
@@ -558,11 +499,12 @@
    
    It is an error to create two variables with the same name.
  */
-yices_var_decl yices_mk_bool_var_decl(yices_context ctx, char * name);
+yices_var_decl yices_mk_bool_var_decl(yices_context ctx, [string] char * name);
 
 /**
    \brief Return a name of a variable declaration.
  */
+[string]
 char * yices_get_var_decl_name(yices_var_decl d);
 
 /**
@@ -577,7 +519,7 @@
 	 
    \warning \c n must be greater than zero.
  */
-yices_expr yices_mk_or(yices_context ctx, yices_expr args[], unsigned n);
+yices_expr yices_mk_or(yices_context ctx, [size_is(n)] yices_expr args[], unsigned int n);
 
 /**
    \brief Return an expression representing the \c and of the given arguments.
@@ -586,7 +528,7 @@
 
    \warning \c n must be greater than zero.
  */
-yices_expr yices_mk_and(yices_context ctx, yices_expr args[], unsigned n);
+yices_expr yices_mk_and(yices_context ctx, [size_is(n)] yices_expr args[], unsigned int n);
 
 /**
    \brief Return an expression representing <tt>a1 = a2</tt>.
@@ -608,6 +550,9 @@
  */
 yices_expr yices_mk_not(yices_context ctx, yices_expr a);
 
+// Don't export the operations on var_decl_iterator
+quote(mli,"(*");
+
 /**
    \brief Create an iterator that can be used to traverse the boolean variables (var_decl objects) in the 
    given logical context. 
@@ -655,7 +600,7 @@
    \sa yices_iterator_next
    \sa yices_create_var_decl_iterator
  */
-int yices_iterator_has_next(yices_var_decl_iterator it);
+boolean yices_iterator_has_next(yices_var_decl_iterator it);
 
 /**
    \brief Return the next variable, and move the iterator.
@@ -675,20 +620,47 @@
  */
 void yices_del_iterator(yices_var_decl_iterator it);
 
+quote(mli,"*)\n");
+
+quote(mli,"(** {i (OCaml-specific)} Applies a function to each boolean variable declarations of a given context. *)")
+
+// MLize the iterator
+quote(ml,"let iter_bool_var_decl f ctx = \n\
+  let it = yices_create_var_decl_iterator ctx in\n\
+    while yices_iterator_has_next it do\n\
+      f (yices_iterator_next it);\n\
+    done;\n\
+    yices_del_iterator it;;\n");
+
+quote(mli,"val iter_bool_var_decl: (yices_var_decl -> unit) -> context -> unit;;\n");
+
 /**
    \brief Return the type associated with the given name. If the type
    does not exist, a new uninterpreted type is created.
 
    \remark number, real, int, nat, bool, any are builtin types.
  */
-yices_type yices_mk_type(yices_context ctx, char * name);
+yices_type yices_mk_type(yices_context ctx, [string] char * name);
+
+// built-in types: number, real, int, nat, bool, any
+quote(ml,"let number_type_name = \"number\";;\n\
+let real_type_name = \"real\";;\n\
+let int_type_name = \"int\";;\n\
+let nat_type_name = \"nat\";;\n\
+let bool_type_name = \"bool\";;\n\
+let any_type_name = \"any\";;\n")
+quote(mli,"val number_type_name : string\n\
+val real_type_name : string\n\
+val int_type_name : string\n\
+val nat_type_name : string\n\
+val bool_type_name : string\n\
+val any_type_name : string\n")
 
 /**
    \brief Return a function type <tt>(-> d1 ... dn r)</tt>.
  */
-yices_type yices_mk_function_type(yices_context ctx, yices_type domain[], 
-				  unsigned domain_size, yices_type range);
-
+yices_type yices_mk_function_type(yices_context ctx, [size_is(domain_size)] yices_type domain[], 
+				  unsigned int domain_size, yices_type range);
 
 
 /**
@@ -696,27 +668,27 @@
    
    Size must be positive.
 */
-yices_type yices_mk_bitvector_type(yices_context ctx, unsigned size);
+yices_type yices_mk_bitvector_type(yices_context ctx, unsigned int size);
 
 
 /**
   \brief Constructs the tuple type (arg[0], ..., arg[size-1]).
 */
-yices_type yices_mk_tuple_type(yices_context ctx, yices_type * args[], unsigned size);
+yices_type yices_mk_tuple_type(yices_context ctx, [size_is(size)] yices_type_ptr args[], unsigned int size);
 
 
 /**
    \brief Return a new (global) variable declaration. It is an error to create two variables
    with the same name.
 */
-yices_var_decl yices_mk_var_decl(yices_context ctx, char * name, yices_type ty);
+yices_var_decl yices_mk_var_decl(yices_context ctx, [string] char * name, yices_type ty);
 
 /**
    \brief Return a variable declaration associated with the given name. 
 
    Return 0 if there is no variable declaration associated with the given name.
 */
-yices_var_decl yices_get_var_decl_from_name(yices_context ctx, char * name);
+yices_var_decl yices_get_var_decl_from_name(yices_context ctx, [string] char * name);
 
 /**
    \brief Return a name expression (instance) using the given variable declaration.
@@ -729,7 +701,7 @@
    The type of \c f must be a function-type, and its arity must
    be equal to the number of arguments.
  */
-yices_expr yices_mk_app(yices_context ctx, yices_expr f, yices_expr args[], unsigned n);
+yices_expr yices_mk_app(yices_context ctx, yices_expr f, [size_is(n)] yices_expr args[], unsigned int n);
 
 
 /**
@@ -740,37 +712,39 @@
 /**
    \brief Return an expression representing the number provided in ASCII format.
  */
-yices_expr yices_mk_num_from_string(yices_context ctx, char * n);
-
-
-/**
-  \brief Construct a numerical expression form a GMP integer
+yices_expr yices_mk_num_from_string(yices_context ctx, [string] char * n);
 
-  \warning
-  - You must include <gmp.h> before <yices_c.h> for this function to be available.
-  - If you don't need GMP numbers, don't include <gmp.h>
 
-  \sa yices_mk_num_from_mpq
-*/
-#ifdef __GMP_H__
-yices_expr yices_mk_num_from_mpz(yices_context ctx, const mpz_t z);
-#endif
-
-
-/**
-  \brief Construct a numerical expression form a GMP rational
+// Use yices_mk_num_from_string instead
+///**
+//  \brief Construct a numerical expression form a GMP integer
+//
+//  \warning
+//  - You must include <gmp.h> before <yices_c.h> for this function to be available.
+//  - If you don't need GMP numbers, don't include <gmp.h>
+//
+//  \sa yices_mk_num_from_mpq
+//*/
+//#ifdef __GMP_H__
+//yices_expr yices_mk_num_from_mpz(yices_context ctx, const mpz_t z);
+//#endif
+
+
+///**
+//  \brief Construct a numerical expression form a GMP rational
+//
+//  q must be canonicalized (see GMP documentation).
+//
+//  \warning
+//  - You must include <gmp.h> before <yices_c.h> for this function to be available.
+//  - If you don't need GMP numbers, don't include <gmp.h>
+//
+//  \sa yices_mk_num_from_mpq
+//*/
+//#ifdef __GMP_H__
+//yices_expr yices_mk_num_from_mpq(yices_context ctx, const mpq_t q);
+//#endif
 
-  q must be canonicalized (see GMP documentation).
-
-  \warning
-  - You must include <gmp.h> before <yices_c.h> for this function to be available.
-  - If you don't need GMP numbers, don't include <gmp.h>
-
-  \sa yices_mk_num_from_mpq
-*/
-#ifdef __GMP_H__
-yices_expr yices_mk_num_from_mpq(yices_context ctx, const mpq_t q);
-#endif
 
 
 /**
@@ -780,7 +754,7 @@
 	 
    \warning \c n must be greater than zero.
  */
-yices_expr yices_mk_sum(yices_context ctx, yices_expr args[], unsigned n);
+yices_expr yices_mk_sum(yices_context ctx, [size_is(n)] yices_expr args[], unsigned int n);
 
 /**
    \brief Return an expression representing <tt>args[0] - ... - args[n-1]</tt>.
@@ -789,7 +763,7 @@
 	 
    \warning \c n must be greater than zero.
  */
-yices_expr yices_mk_sub(yices_context ctx, yices_expr args[], unsigned n);
+yices_expr yices_mk_sub(yices_context ctx, [size_is(n)] yices_expr args[], unsigned int n);
 
 /**
    \brief Return an expression representing <tt>args[0] * ... * args[n-1]</tt>.
@@ -798,7 +772,7 @@
 	 
    \warning \c n must be greater than zero.
  */
-yices_expr yices_mk_mul(yices_context ctx, yices_expr args[], unsigned n);
+yices_expr yices_mk_mul(yices_context ctx, [size_is(n)] yices_expr args[], unsigned int n);
 
 /**
    \brief Return an expression representing <tt>a1 < a2</tt>.
@@ -828,7 +802,7 @@
 
    \c size must be positive
 */
-yices_expr yices_mk_bv_constant(yices_context ctx, unsigned size, unsigned long value);
+yices_expr yices_mk_bv_constant(yices_context ctx, unsigned int size, unsigned long val);
 
 
 /**
@@ -839,7 +813,7 @@
 
    bit \c i of the bitvector is set to 0 if <tt>bv[i] = 0</tt> and to 1 if <tt>bv[i] != 0</tt>
 */
-yices_expr yices_mk_bv_constant_from_array(yices_context ctx, unsigned size, int bv[]);
+yices_expr yices_mk_bv_constant_from_array(yices_context ctx, unsigned int size, [size_is(size)] boolean bv[]);
 
 
 /**
@@ -919,37 +893,37 @@
   \c a must a bitvector expression of size \c n with \c begin < \c end < \c n.
   The result is the subvector \c a[begin .. end]
 */ 
-yices_expr yices_mk_bv_extract(yices_context ctx, unsigned end, unsigned begin, yices_expr a);
+yices_expr yices_mk_bv_extract(yices_context ctx, unsigned int end, unsigned int begin, yices_expr a);
 
 /**
   \brief Sign extension
 
   Append \c n times the most-significant bit of \a to the left of \c a
 */
-yices_expr yices_mk_bv_sign_extend(yices_context ctx, yices_expr a, unsigned n);
+yices_expr yices_mk_bv_sign_extend(yices_context ctx, yices_expr a, unsigned int n);
 
 
 /** 
   \brief Left shift by \c n bits, padding with zeros
 */
-yices_expr yices_mk_bv_shift_left0(yices_context ctx, yices_expr a, unsigned n);
+yices_expr yices_mk_bv_shift_left0(yices_context ctx, yices_expr a, unsigned int n);
 
 
 /** 
   \brief Left shift by \c n bits, padding with ones
 */
-yices_expr yices_mk_bv_shift_left1(yices_context ctx, yices_expr a, unsigned n);
+yices_expr yices_mk_bv_shift_left1(yices_context ctx, yices_expr a, unsigned int n);
 
 /** 
   \brief Right shift by \c n bits, padding with zeros
 */
-yices_expr yices_mk_bv_shift_right0(yices_context ctx, yices_expr a, unsigned n);
+yices_expr yices_mk_bv_shift_right0(yices_context ctx, yices_expr a, unsigned int n);
 
 
 /** 
   \brief Right shift by \c n bits, padding with ones
 */
-yices_expr yices_mk_bv_shift_right1(yices_context ctx, yices_expr a, unsigned n);
+yices_expr yices_mk_bv_shift_right1(yices_context ctx, yices_expr a, unsigned int n);
 
 
 /**
@@ -1019,10 +993,29 @@
 */
 void yices_pp_expr(yices_expr e);
 
-#ifdef __cplusplus
-} /* end of extern "C" */
-#endif
 
+quote(mli,"(** Untested and potentially harmful features *)")
+quote(ml,"module Future = struct\n")
+quote(mli,"module Future : sig\n")
+
+quote(mli,"(** Given on yices-help by Bruno Dutertre (2009-12-16) *)")
+void yices_interrupt(yices_context ctx);
+
+quote(mli,"(** Get the Lite context out of a Full context.\n\
+  Be aware to close only the full context!\n\n\
+  Given on yices-help by Bruno Dutertre (2010-06-01)\n\
+*)")
+yicesl_context yices_get_lite_context(yices_context ctx);
+
+quote(mli, "(** Make a function update.\n\n\
+  Found with 'nm': seems to work pretty well\n*)")
+yices_expr yices_mk_function_update(yices_context ctx, yices_expr f, [size_is(n)] yices_expr args[], unsigned int n, yices_expr val);
+
+quote(mli, "(** Make a tuple.\n\n\
+  Found with 'nm': seems to work but no really useful without 'select' *)")
+yices_expr yices_mk_tuple_literal(yices_context ctx, [size_is(n)] yices_expr args[], unsigned int n);
+
+quote(ml,"end\n")
+quote(mli,"end\n")
 
-/*@}*/
-#endif /* YICES_C_H */
+} /* interface */
